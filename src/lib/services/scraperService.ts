import * as cheerio from 'cheerio';
import { songService } from './songService';

/**
 * Configuration pour diff√©rents sites de partitions
 * Vous pouvez ajouter vos propres sites ici
 */
interface ScraperConfig {
  name: string;
  searchUrl: (query: string) => string;
  selectors: {
    searchResults?: string;
    songTitle?: string;
    songAuthor?: string;
    songContent?: string;
    songLink?: string;
  };
}

// Exemple de configuration pour diff√©rents sites
// √Ä adapter selon les sites que vous souhaitez scraper
const scraperConfigs: ScraperConfig[] = [
  {
    name: 'Guitar Tabs',
    searchUrl: (query) => `https://www.ultimate-guitar.com/search.php?search_type=title&value=${encodeURIComponent(query)}`,
    selectors: {
      searchResults: '.js-search-result',
      songTitle: 'h3.title',
      songAuthor: '.artist',
      songLink: 'a[href*="/tab/"]',
    }
  },
  {
    name: 'Tabs4Acoustic',
    searchUrl: (query) => `https://www.tabs4acoustic.com/en/guitar-tabs/${encodeURIComponent(query)}`,
    selectors: {
      songTitle: '.song-title',
      songAuthor: '.artist-name',
      songContent: 'pre.tab-content, .chord-sheet',
    }
  },
  // Ajoutez vos propres configurations de sites ici
];

export interface ScrapedSong {
  title: string;
  author: string;
  content: string;
  source: string;
  url?: string;
}

export interface SearchResult {
  title: string;
  author: string;
  url: string;
  source: string;
  reviews?: number; // Nombre de reviews/√©valuations
}

/**
 * Nettoie et formate le contenu de la partition
 */
function cleanSongContent(content: string): string {
  // Nettoyer les balises [ch] et [/ch] des tabs
  let cleaned = content.replace(/\[ch\]/g, '').replace(/\[\/ch\]/g, '');
  cleaned = cleaned.replace(/\[tab\]/g, '').replace(/\[\/tab\]/g, '');
  
  return cleaned
    .trim()
    .replace(/\r\n/g, '\n')
    .replace(/\n{3,}/g, '\n\n')
    .replace(/^\s+|\s+$/g, '');
}

/**
 * D√©code les entit√©s HTML
 */
function decodeHTMLEntities(text: string): string {
  return text
    .replace(/&quot;/g, '"')
    .replace(/&amp;/g, '&')
    .replace(/&#39;/g, "'")
    .replace(/&#x27;/g, "'")
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>');
}

/**
 * Scraper sp√©cialis√© pour les tabs de guitare
 * Utilise des donn√©es JSON dans l'attribut data-content
 */
async function scrapeUltimateGuitar(url: string): Promise<ScrapedSong | null> {
  try {
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
      },
    });

    if (!response.ok) {
      return null;
    }

    const html = await response.text();
    const $ = cheerio.load(html);

    // Les donn√©es sont stock√©es dans l'attribut data-content
    const dataContent = $('.js-store').attr('data-content');
    
    if (!dataContent) {
      return null;
    }

    // D√©coder les entit√©s HTML et parser le JSON
    const decodedData = decodeHTMLEntities(dataContent);
    const data = JSON.parse(decodedData);

    // Extraire les donn√©es depuis data.store.page.data.tab_view
    const tabView = data.store?.page?.data?.tab_view;
    
    if (!tabView) {
      console.log('‚ùå No tab_view found in data structure');
      console.log('üîç Available keys in data.store.page.data:', Object.keys(data.store?.page?.data || {}));
      return null;
    }
    
    // Debug: afficher toutes les cl√©s disponibles dans tabView
    console.log('üîç TabView structure:', {
      hasWikiTab: !!tabView.wiki_tab,
      hasMeta: !!tabView.meta,
      allKeys: Object.keys(tabView).slice(0, 10) // Premiers 10 keys seulement
    });
    
    const tab = tabView.wiki_tab;
    
    if (!tab?.content) {
      console.log('‚ùå No wiki_tab content found');
      return null;
    }

    const content = tab.content;
    
    // Extraire le titre et l'auteur avec plusieurs fallbacks
    let title = 'Sans titre';
    let author = 'Auteur inconnu';
    
    // Essayer diff√©rentes sources pour le titre
    if (tabView.meta?.title) {
      title = tabView.meta.title;
    } else if (tab.song_name) {
      title = tab.song_name;
    } else if (tabView.song_name) {
      title = tabView.song_name;
    }
    
    // Essayer diff√©rentes sources pour l'auteur
    if (tabView.meta?.artist) {
      author = tabView.meta.artist;
    } else if (tab.artist_name) {
      author = tab.artist_name;
    } else if (tabView.artist_name) {
      author = tabView.artist_name;
    } else if (tab.band_name) {
      author = tab.band_name;
    } else if (tabView.band_name) {
      author = tabView.band_name;
    }

    console.log(`üéµ Extracted from Ultimate Guitar: "${title}" by "${author}"`);
    
    // Debug: montrer ce qu'on a trouv√©
    if (title === 'Sans titre' || author === 'Auteur inconnu') {
      console.log('‚ö†Ô∏è Missing data. Available in meta:', {
        meta: tabView.meta ? Object.keys(tabView.meta) : 'none',
        wikiTab: tab ? Object.keys(tab).filter(k => k !== 'content').slice(0, 5) : 'none'
      });
    }

    return {
      title,
      author,
      content: cleanSongContent(content),
      source: 'Ultimate Guitar',
      url,
    };
  } catch (error) {
    console.error('Error scraping guitar tabs:', error);
    return null;
  }
}

/**
 * Recherche sur les tabs de guitare
 */
export async function searchUltimateGuitarOnly(query: string): Promise<SearchResult[]> {
  const results: SearchResult[] = [];

  try {
    const searchUrl = `https://www.ultimate-guitar.com/search.php?search_type=title&value=${encodeURIComponent(query)}`;
    const response = await fetch(searchUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
      },
    });

    if (!response.ok) {
      return results;
    }

    const html = await response.text();
    const $ = cheerio.load(html);

    // Extraire les donn√©es JSON
    const dataContent = $('.js-store').attr('data-content');
    
    if (!dataContent) {
      return results;
    }

    const decodedData = decodeHTMLEntities(dataContent);
    const data = JSON.parse(decodedData);

    const searchResults = data.store?.page?.data?.results;
    
    if (!searchResults || !Array.isArray(searchResults)) {
      return results;
    }

    // Filtrer uniquement les tabs gratuites (pas les tabs Pro)
    const filteredResults = searchResults
      .filter((result: any) => {
        // Exclure les tabs Pro
        return result.tab_url && 
               !result.tab_url.includes('/pro/') && 
               (result.type === 'Chords' || result.type === 'Tab' || result.type);
      })
      .map((result: any) => ({
        title: result.song_name || 'Sans titre',
        author: result.artist_name || 'Inconnu',
        url: result.tab_url,
        source: 'Guitar Tabs',
        reviews: result.votes || 0, // Nombre de votes/avis
      }))
      .sort((a, b) => b.reviews - a.reviews) // Trier par nombre de reviews (d√©croissant)
      .slice(0, 10); // Limiter √† 10 r√©sultats

    results.push(...filteredResults);

  } catch (error) {
    console.error('Error searching guitar tabs:', error);
  }

  return results;
}

/**
 * Scraper sp√©cialis√© pour Tab4U (site isra√©lien)
 * Tab4U structure le contenu dans des tables avec des spans pour les accords
 */
async function scrapeTab4U(url: string): Promise<ScrapedSong | null> {
  try {
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
        'Accept-Language': 'he-IL,he;q=0.9,en-US;q=0.8,en;q=0.7',
      },
    });

    if (!response.ok) {
      return null;
    }

    const html = await response.text();
    const $ = cheerio.load(html);

    // Extraire le titre depuis h1
    let title = $('h1').first().text().trim();
    // Nettoyer le titre (ex: "◊ê◊ß◊ï◊®◊ì◊ô◊ù ◊ú◊©◊ô◊® XXX ◊©◊ú YYY" -> "XXX")
    title = title.replace(/^◊ê◊ß◊ï◊®◊ì◊ô◊ù ◊ú◊©◊ô◊®\s+/, '').replace(/\s+◊©◊ú\s+.*$/, '');

    // Extraire l'auteur (artiste)
    const artistLink = $('a.artistTitle').first();
    let author = artistLink.text().trim();
    
    // Alternative: chercher dans les m√©tadonn√©es
    if (!author) {
      const artistMeta = $('[class*="artist"]').first().text().trim();
      author = artistMeta;
    }

    // Extraire le contenu depuis les tables
    let content = '';
    const tables = $('table');
    
    tables.each((i: number, elem: any) => {
      const $table = $(elem);
      const tableText = $table.text();
      
      // V√©rifier si cette table contient des accords
      const chordCount = (tableText.match(/\b[A-G][#b]?(m|maj|min|dim|aug|sus)?[0-9]?\b/g) || []).length;
      
      if (chordCount > 5) {
        // Extraire le contenu ligne par ligne
        const rows = $table.find('tr');
        
        rows.each((j: number, row: any) => {
          const $row = $(row);
          const cells = $row.find('td');
          
          cells.each((k: number, cell: any) => {
            const $cell = $(cell);
            const cellText = $cell.text().trim();
            
            if (cellText) {
              content += cellText + '\n';
            }
          });
        });
      }
    });

    // Alternative: chercher dans div#songContentTPL
    if (!content || content.length < 100) {
      const songDiv = $('#songContentTPL');
      if (songDiv.length > 0) {
        content = songDiv.text().trim();
      }
    }

    if (!content || content.length < 50) {
      return null;
    }

    return {
      title: title || 'Sans titre',
      author: author || 'Auteur inconnu',
      content: cleanSongContent(content),
      source: 'Tab4U',
      url,
    };
  } catch (error) {
    console.error('Error scraping Tab4U:', error);
    return null;
  }
}

/**
 * Recherche sur Tab4U (site isra√©lien)
 */
export async function searchTab4UOnly(query: string): Promise<SearchResult[]> {
  const results: SearchResult[] = [];

  try {
    const searchUrl = `https://www.tab4u.com/resultsSimple?tab=songs&q=${encodeURIComponent(query)}`;
    const response = await fetch(searchUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
        'Accept-Language': 'he-IL,he;q=0.9,en-US;q=0.8,en;q=0.7',
      },
    });

    if (!response.ok) {
      return results;
    }

    const html = await response.text();
    const $ = cheerio.load(html);

    // Tab4U structure: <a href="tabs/songs/...">Title / Artist</a>
    const songLinks = $('a[href*="tabs/songs/"]');
    
    songLinks.slice(0, 10).each((i: number, elem: any) => {
      const $link = $(elem);
      const href = $link.attr('href');
      const fullText = $link.text().trim();
      
      // Ignorer les liens avec "◊ú◊ú◊ê ◊ê◊ß◊ï◊®◊ì◊ô◊ù" (sans accords)
      if (fullText.includes('◊ú◊ú◊ê ◊ê◊ß◊ï◊®◊ì◊ô◊ù')) {
        return;
      }
      
      // Format du texte: "Titre / Artiste" ou "Titre - Artiste"
      const parts = fullText.split(/[/\-]/).map(p => p.trim());
      const title = parts[0] || fullText;
      const author = parts[1] || '';
      
      if (href && title) {
        const fullUrl = href.startsWith('http') 
          ? href 
          : `https://www.tab4u.com/${href}`;
          
        results.push({
          title,
          author: author || 'Unknown',
          url: fullUrl,
          source: 'Tab4U',
          reviews: 0, // Tab4U ne fournit pas de donn√©es de reviews
        });
      }
    });

  } catch (error) {
    console.error('Error searching Tab4U:', error);
  }

  return results;
}

/**
 * Recherche une chanson sur diff√©rents sites
 */
export async function searchSong(query: string): Promise<SearchResult[]> {
  const results: SearchResult[] = [];

  // 1. Recherche sur les tabs de guitare (priorit√© car meilleure qualit√©)
  try {
    const ugResults = await searchUltimateGuitarOnly(query);
    results.push(...ugResults);
  } catch (error) {
    console.error('Error searching guitar tabs:', error);
  }

  // 2. Si pas assez de r√©sultats, chercher sur Tab4U
  if (results.length < 5) {
    try {
      const tab4uResults = await searchTab4UOnly(query);
      results.push(...tab4uResults);
    } catch (error) {
      console.error('Error searching Tab4U:', error);
    }
  }

  return results;
}

/**
 * R√©cup√®re le contenu d'une partition depuis une URL
 */
export async function scrapeSongFromUrl(url: string): Promise<ScrapedSong | null> {
  try {
    // D√©tecter le site et utiliser le scraper appropri√©
    const hostname = new URL(url).hostname;

    // Guitar tabs
    if (hostname.includes('ultimate-guitar.com') || hostname.includes('tabs.ultimate-guitar.com')) {
      return await scrapeUltimateGuitar(url);
    }

    // Tab4U
    if (hostname.includes('tab4u.com')) {
      return await scrapeTab4U(url);
    }

    // Pour les autres sites, utiliser le scraper g√©n√©rique
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
      },
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const html = await response.text();
    const $ = cheerio.load(html);

    // Essayez diff√©rents s√©lecteurs communs
    let title = '';
    let author = '';
    let content = '';

    // S√©lecteurs g√©n√©riques pour le titre
    const titleSelectors = [
      'h1',
      '.song-title',
      '.title',
      '[class*="song-name"]',
      '[class*="track-name"]',
    ];

    for (const selector of titleSelectors) {
      const text = $(selector).first().text().trim();
      if (text && text.length > 0) {
        title = text;
        break;
      }
    }

    // S√©lecteurs g√©n√©riques pour l'auteur
    const authorSelectors = [
      '.artist',
      '.author',
      '.artist-name',
      '[class*="artist"]',
      'h2',
    ];

    for (const selector of authorSelectors) {
      const text = $(selector).first().text().trim();
      if (text && text.length > 0 && text !== title) {
        author = text;
        break;
      }
    }

    // S√©lecteurs g√©n√©riques pour le contenu
    const contentSelectors = [
      'pre',
      '.tab-content',
      '.chord-sheet',
      '[class*="tab"]',
      '[class*="chord"]',
      '.song-content',
      'code',
    ];

    for (const selector of contentSelectors) {
      const text = $(selector).first().text();
      if (text && text.length > 100) {
        content = cleanSongContent(text);
        break;
      }
    }

    // Si on n'a pas trouv√© de contenu structur√©, essayez de r√©cup√©rer tout le texte
    if (!content) {
      const bodyText = $('body').text();
      // Chercher des patterns d'accords (C, G, Am, etc.)
      const chordPattern = /\b[A-G][#b]?(m|maj|min|dim|aug|sus|add)?[0-9]?\b/g;
      const matches = bodyText.match(chordPattern);
      
      if (matches && matches.length > 5) {
        // Il semble y avoir des accords, essayons de r√©cup√©rer le contexte
        content = cleanSongContent(bodyText.substring(0, 3000));
      }
    }

    if (!content) {
      throw new Error('Impossible de trouver le contenu de la partition');
    }

    return {
      title: title || 'Sans titre',
      author: author || 'Auteur inconnu',
      content,
      source: hostname,
      url,
    };
  } catch (error) {
    console.error('Error scraping song:', error);
    return null;
  }
}

/**
 * Recherche et r√©cup√®re directement une chanson (meilleur r√©sultat)
 */
export async function searchAndScrapeSong(query: string): Promise<ScrapedSong | null> {
  try {
    // Rechercher la chanson
    const searchResults = await searchSong(query);

    if (searchResults.length === 0) {
      return null;
    }

    // Prendre le premier r√©sultat et r√©cup√©rer son contenu
    const firstResult = searchResults[0];
    const song = await scrapeSongFromUrl(firstResult.url);

    return song;
  } catch (error) {
    console.error('Error in searchAndScrapeSong:', error);
    return null;
  }
}

/**
 * Interface pour les playlists Ultimate Guitar
 */
export interface PlaylistSong {
  title: string;
  artist: string;
  url?: string;
  playlistName?: string;
}

export interface PlaylistData {
  name: string;
  songs: PlaylistSong[];
}

/**
 * Scraper pour les playlists Ultimate Guitar (page mytabs)
 * N√©cessite des cookies d'authentification
 */
export async function scrapeUltimateGuitarPlaylists(
  cookies: string,
  userAgent?: string
): Promise<PlaylistData[]> {
  try {
    const response = await fetch('https://www.ultimate-guitar.com/user/mytabs', {
      headers: {
        'User-Agent': userAgent || 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
        'Cookie': cookies,
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.5',
        'Accept-Encoding': 'gzip, deflate, br',
        'Connection': 'keep-alive',
        'Upgrade-Insecure-Requests': '1',
      },
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const html = await response.text();
    const $ = cheerio.load(html);

    // V√©rifier si l'utilisateur est connect√©
    if (html.includes('Please log in') || html.includes('login')) {
      throw new Error('User not authenticated. Please provide valid cookies.');
    }

    const playlists: PlaylistData[] = [];
    
    // Chercher les diff√©rentes sections de playlists
    // Structure possible: playlists, bookmarks, favorites, etc.
    const playlistSections = [
      { selector: '.js-store', name: 'My Tabs' },
      { selector: '[data-content*="bookmarks"]', name: 'Bookmarks' },
      { selector: '[data-content*="favorites"]', name: 'Favorites' },
    ];

    for (const section of playlistSections) {
      const sectionElement = $(section.selector);
      
      if (sectionElement.length > 0) {
        // Extraire les donn√©es JSON comme pour la recherche normale
        const dataContent = sectionElement.attr('data-content');
        
        if (dataContent) {
          try {
            const decodedData = decodeHTMLEntities(dataContent);
            const data = JSON.parse(decodedData);
            
            // Analyser la structure des donn√©es pour extraire les playlists
            const playlistsData = extractPlaylistsFromData(data);
            
            if (playlistsData.length > 0) {
              playlists.push(...playlistsData.map(p => ({
                ...p,
                name: p.name || section.name
              })));
            }
          } catch (parseError) {
            console.warn(`Error parsing data for section ${section.name}:`, parseError);
          }
        }
      }
    }

    // Alternative: scraper bas√© sur le HTML si les donn√©es JSON ne sont pas disponibles
    if (playlists.length === 0) {
      const htmlPlaylists = scrapePlaylistsFromHTML($);
      playlists.push(...htmlPlaylists);
    }

    return playlists;

  } catch (error) {
    console.error('Error scraping Ultimate Guitar playlists:', error);
    throw error;
  }
}

/**
 * Extrait les playlists depuis les donn√©es JSON
 */
function extractPlaylistsFromData(data: any): PlaylistData[] {
  const playlists: PlaylistData[] = [];
  
  // Structure r√©elle d√©couverte : data.store.page.data.list.list
  if (data.store?.page?.data?.list?.list && Array.isArray(data.store.page.data.list.list)) {
    const songs = data.store.page.data.list.list;
    
    console.log(`üéµ Found ${songs.length} favorite songs`);
    
    // Convertir les chansons favorites en playlist
    const playlistSongs = songs.map((song: any) => ({
      title: song.song_name || 'Unknown',
      artist: song.band_name || 'Unknown',
      url: song.song_url,
      playlistName: 'My Favorites'
    }));
    
    if (playlistSongs.length > 0) {
      playlists.push({
        name: 'My Favorites',
        songs: playlistSongs
      });
    }
  }
  
  // Structure alternative pour les playlists classiques (si elles existent)
  if (data.store?.page?.data?.playlists) {
    const playlistsData = data.store.page.data.playlists;
    
    if (Array.isArray(playlistsData)) {
      for (const playlist of playlistsData) {
        if (playlist.songs && Array.isArray(playlist.songs)) {
          playlists.push({
            name: playlist.name || 'Unnamed Playlist',
            songs: playlist.songs.map((song: any) => ({
              title: song.song_name || song.title || 'Unknown',
              artist: song.artist_name || song.artist || 'Unknown',
              url: song.tab_url || song.url,
            }))
          });
        }
      }
    }
  }
  
  return playlists;
}

/**
 * Scraper alternatif bas√© sur le HTML
 */
function scrapePlaylistsFromHTML($: cheerio.CheerioAPI): PlaylistData[] {
  const playlists: PlaylistData[] = [];
  
  // Chercher les liens vers les tabs dans la page
  const songLinks = $('a[href*="/tab/"], a[href*="/tabs/"]');
  
  if (songLinks.length > 0) {
    const songs: PlaylistSong[] = [];
    
    songLinks.each((i, elem) => {
      const $link = $(elem);
      const href = $link.attr('href');
      const text = $link.text().trim();
      
      if (href && text && !text.includes('Pro') && !text.includes('Official')) {
        // Extraire le titre et l'artiste du texte
        const parts = text.split(' - ');
        const title = parts[0] || text;
        const artist = parts[1] || 'Unknown';
        
        songs.push({
          title,
          artist,
          url: href.startsWith('http') ? href : `https://www.ultimate-guitar.com${href}`
        });
      }
    });
    
    if (songs.length > 0) {
      playlists.push({
        name: 'My Tabs',
        songs
      });
    }
  }
  
  return playlists;
}

/**
 * Importe automatiquement les meilleures versions des chansons d'une playlist
 */
export async function importPlaylistSongs(
  playlistData: PlaylistData,
  userId: string,
  targetFolderId?: string,
  maxConcurrent: number = 3,
  clientSupabase?: any
): Promise<{ success: number; failed: number; duplicates: number; errors: string[] }> {
  const results = { success: 0, failed: 0, duplicates: 0, errors: [] as string[] };
  
  // Traiter les chansons par batch pour √©viter de surcharger le serveur
  for (let i = 0; i < playlistData.songs.length; i += maxConcurrent) {
    const batch = playlistData.songs.slice(i, i + maxConcurrent);
    
    const promises = batch.map(async (song) => {
      try {
        // Utiliser directement l'URL de la chanson favorite si disponible
        if (song.url) {
          console.log(`üéµ Scraping favorite song: ${song.title} by ${song.artist}`);
          console.log(`üîó URL: ${song.url}`);
          
          // Scraper directement le contenu de la chanson favorite
          const scrapedSong = await scrapeSongFromUrl(song.url);
          
          if (!scrapedSong) {
            console.log(`‚ùå Failed to scrape favorite song: ${song.title}`);
            results.errors.push(`Failed to scrape favorite song: ${song.title}`);
            results.failed++;
            return;
          }
          
          // PRIORIT√â AUX DONN√âES DE LA PLAYLIST (on les a d√©j√† !)
          const finalSong = {
            ...scrapedSong,
            title: song.title || scrapedSong.title || 'Sans titre',
            author: song.artist || scrapedSong.author || 'Auteur inconnu'
          };
          
          console.log(`‚úÖ Successfully scraped: ${finalSong.title} by ${finalSong.author}`);
          
            // Importer dans la base de donn√©es Supabase
            const importStatus = await importSongToDatabase(finalSong, userId, targetFolderId, clientSupabase);
            
            if (importStatus === 'success') {
              results.success++;
            } else if (importStatus === 'duplicate') {
              results.duplicates++;
            } else {
              results.failed++;
              results.errors.push(`Database import failed for ${song.title}`);
            }
          
        } else {
          // Fallback: rechercher si pas d'URL disponible
          const searchQuery = `${song.artist} ${song.title}`;
          console.log(`üîç No URL available, searching for: ${searchQuery}`);
          
          const searchResults = await searchUltimateGuitarOnly(searchQuery);
          
          if (searchResults.length === 0) {
            results.errors.push(`No results found for: ${searchQuery}`);
            results.failed++;
            return;
          }
          
          // Prendre la premi√®re version (d√©j√† tri√©e par reviews)
          const bestVersion = searchResults[0];
          
          // Scraper le contenu de cette version
          const scrapedSong = await scrapeSongFromUrl(bestVersion.url);
          
          if (!scrapedSong) {
            results.errors.push(`Failed to scrape content for: ${searchQuery}`);
            results.failed++;
            return;
          }
          
            // Importer dans la base de donn√©es Supabase
            const importStatus = await importSongToDatabase(scrapedSong, userId, targetFolderId, clientSupabase);
            
            if (importStatus === 'success') {
              results.success++;
            } else if (importStatus === 'duplicate') {
              results.duplicates++;
            } else {
              results.failed++;
              results.errors.push(`Database import failed for ${searchQuery}`);
            }
        }
        
      } catch (error) {
        results.errors.push(`Error processing ${song.title}: ${error}`);
        results.failed++;
      }
    });
    
    await Promise.all(promises);
    
    // D√©lai entre les batches pour √™tre respectueux
    if (i + maxConcurrent < playlistData.songs.length) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
  
  return results;
}

/**
 * Importe une chanson scrapp√©e dans la base de donn√©es Supabase
 */
async function importSongToDatabase(scrapedSong: ScrapedSong, userId: string, targetFolderId?: string, clientSupabase?: any): Promise<'success' | 'duplicate' | 'error'> {
  try {
    console.log(`üì• Importing to database: ${scrapedSong.title} by ${scrapedSong.author}`);
    
    // V√©rifier si la chanson existe d√©j√† pour cet utilisateur avec le bon client
    const existingSongs = await songService.searchSongs(`${scrapedSong.title} ${scrapedSong.author}`, clientSupabase);
    const duplicate = existingSongs.find(song => 
      song.title.toLowerCase() === scrapedSong.title.toLowerCase() &&
      song.author.toLowerCase() === scrapedSong.author.toLowerCase()
    );
    
    if (duplicate) {
      console.log(`‚ö†Ô∏è Song already exists: ${scrapedSong.title} by ${scrapedSong.author} (ID: ${duplicate.id})`);
      return 'duplicate'; // Skip duplicate
    }
    
    // Cr√©er la nouvelle chanson avec le userId
    const newSongData = {
      title: scrapedSong.title,
      author: scrapedSong.author,
      content: scrapedSong.content,
      userId: userId,
      folderId: targetFolderId || undefined
    };
    
        const createdSong = await songService.createSong(newSongData, clientSupabase);
    console.log(`‚úÖ Successfully imported: ${createdSong.title} (ID: ${createdSong.id})`);
    return 'success';
    
  } catch (error) {
    console.error('Error importing song to database:', error);
    return 'error';
  }
}

/**
 * Scraper personnalis√© pour un site sp√©cifique
 * Vous pouvez cr√©er des fonctions sp√©cifiques pour vos sites autoris√©s
 */
export async function scrapeFromCustomSite(url: string): Promise<ScrapedSong | null> {
  try {
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
      },
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const html = await response.text();
    const $ = cheerio.load(html);

    // PERSONNALISEZ ICI selon votre site
    // Exemple :
    const title = $('h1.song-title').text().trim();
    const author = $('.artist-name').text().trim();
    const content = $('pre.song-content').text().trim();

    return {
      title: title || 'Sans titre',
      author: author || 'Auteur inconnu',
      content: cleanSongContent(content),
      source: new URL(url).hostname,
      url,
    };
  } catch (error) {
    console.error('Error scraping custom site:', error);
    return null;
  }
}

