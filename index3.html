<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Ma BibliothÃ¨que de Chansons â€” RÃ©parÃ©e</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  body{font-family:Inter, Arial, sans-serif;background:#f3f4f6;color:#111;padding:18px;}
  .container{max-width:1100px;margin:0 auto;}
  .card{background:#fff;border-radius:10px;padding:12px;box-shadow:0 1px 6px rgba(0,0,0,0.06);}
  .chord-inline{color:#0366d6;cursor:pointer;font-weight:700;text-decoration:underline;}
  .instrument-toggle button{padding:8px 12px;border-radius:8px;border:1px solid #e5e7eb;background:#fff;cursor:pointer;}
  .instrument-toggle .active{background:#0b5fff;color:#fff;border-color:#0b5fff;}
  pre{white-space:pre-wrap;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;}
  .kbd{font-size:13px;text-align:center;margin-bottom:8px;}
  .diagram-box{border:1px solid #e5e7eb;padding:10px;border-radius:8px;background:#fafafa;}
  .piano-row{display:flex;gap:6px;justify-content:center;align-items:flex-end;margin-bottom:6px;}
  .white-key{width:28px;height:90px;border:1px solid #cfcfcf;background:#fff;display:flex;align-items:flex-end;justify-content:center;font-size:10px;color:#444;}
  .black-key{width:18px;height:56px;background:#111827;margin-left:-9px;margin-right:-9px;display:inline-block;}
  .white-active{background:#fde68a !important;}
  .black-active{background:#f97316 !important;}
  .guitar-grid{display:grid;grid-template-columns:repeat(6,40px);grid-auto-rows:36px;gap:0;align-items:center;justify-content:center;margin-top:6px;}
  .guitar-cell{border-right:1px solid #d1d5db;border-bottom:1px solid #d1d5db;display:flex;align-items:center;justify-content:center;background:#fff;}
  .dot{width:18px;height:18px;border-radius:50%;background:#0b5fff;}
  .open{color:#059669;font-weight:700;}
  .muted{color:#ef4444;font-weight:700;}
  .small{font-size:12px;color:#6b7280;}
</style>
</head>
<body>
  <div class="container space-y-4">

    <div class="card">
      <h1 class="text-xl font-bold mb-1">ðŸŽ¸ Ma bibliothÃ¨que de chansons</h1>
      <p class="small text-gray-600">Colle/importe des chansons, sauvegarde-les en local. Clique sur un accord pour voir piano/guitare.</p>
    </div>

    <div class="grid md:grid-cols-3 gap-4">

      <!-- Left : ajout/import/actions -->
      <div class="space-y-4">
        <div class="card">
          <h2 class="font-semibold">Ajouter / coller une chanson</h2>
          <label class="text-xs mt-2">Titre</label>
          <input id="input-title" class="w-full border rounded p-2 mb-2" placeholder="Titre (ex: Someone You Loved)"/>
          <label class="text-xs">Auteur</label>
          <input id="input-author" class="w-full border rounded p-2 mb-2" placeholder="Auteur (ex: Lewis Capaldi)"/>
          <label class="text-xs">Texte (accords + paroles)</label>
          <textarea id="input-content" rows="8" class="w-full border rounded p-2 mb-2" placeholder="Colle le texte de la chanson ici..."></textarea>
          <div id="detect-info" class="text-sm text-green-700 mb-2 hidden"></div>
          <div class="flex gap-2">
            <button id="save-btn" class="flex-1 bg-blue-600 text-white p-2 rounded">Enregistrer la chanson</button>
            <button id="clear-form" class="flex-1 border p-2 rounded">Effacer</button>
          </div>
        </div>

        <div class="card">
          <h2 class="font-semibold">Importer des .txt (multi)</h2>
          <input id="file-input" type="file" accept=".txt,text/plain" multiple class="mb-3"/>
          <div id="import-info" class="text-sm text-green-600"></div>
        </div>

        <div class="card">
          <h2 class="font-semibold">Actions</h2>
          <div class="flex flex-col gap-2 mt-2">
            <button id="export-json" class="p-2 border rounded">Exporter la bibliothÃ¨que (JSON)</button>
            <button id="clear-all" class="p-2 border rounded text-red-600">Supprimer toutes les chansons</button>
            <div class="small mt-2">Les chansons sont stockÃ©es uniquement dans ton navigateur (localStorage).</div>
          </div>
        </div>
      </div>

      <!-- Right : liste & vue -->
      <div class="md:col-span-2 space-y-4">
        <div class="card">
          <h2 class="font-semibold">Liste des chansons</h2>
          <ul id="song-list" class="mt-2 space-y-2 max-h-48 overflow-auto"></ul>
          <div id="no-songs" class="text-sm text-gray-500 mt-2 hidden">Aucune chanson â€” ajoute ta premiÃ¨re chanson !</div>
        </div>

        <div id="song-view" class="card hidden">
          <div class="flex items-start justify-between">
            <div>
              <h3 id="view-title" class="text-lg font-bold"></h3>
              <div id="view-author" class="text-sm text-gray-600"></div>
            </div>
            <div class="flex items-center gap-2">
              <div class="instrument-toggle" title="Choisir affichage">
                <button id="pianoBtn" class="active">ðŸŽ¹ Piano</button>
                <button id="guitarBtn">ðŸŽ¸ Guitare</button>
              </div>
              <button id="btn-edit" class="border p-2 rounded text-sm">Ã‰diter</button>
              <button id="btn-delete" class="border p-2 rounded text-sm text-red-600">Supprimer</button>
              <button id="btn-back" class="border p-2 rounded text-sm">Retour</button>
            </div>
          </div>

          <div id="view-content" class="whitespace-pre-wrap bg-gray-50 p-3 rounded mt-3" style="min-height:260px;"></div>

          <div id="diagram-area" class="mt-3 hidden">
            <h4 class="small mb-2">Diagramme</h4>
            <div id="diagram-box" class="diagram-box"></div>
          </div>

          <div id="edit-area" class="mt-3 hidden">
            <label class="text-xs">Modifier le texte</label>
            <textarea id="edit-content" rows="8" class="w-full border rounded p-2"></textarea>
            <div class="flex gap-2 mt-2">
              <button id="save-edit" class="bg-green-600 text-white p-2 rounded">Sauvegarder</button>
              <button id="cancel-edit" class="border p-2 rounded">Annuler</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <footer class="small text-gray-500 mt-6">Si quelque chose ne va pas, dis exactement quel bouton / quelle chanson / quel accord et je corrige immÃ©diatement.</footer>
  </div>

<script>
/* ======================
   Variables & Ã©lÃ©ments
   ====================== */
const STORAGE_KEY = 'songsLibrary_v1';
let songs = [];
let currentIndex = null;
let instrument = 'piano'; // default
let currentChordDisplay = null;

const songListEl = document.getElementById('song-list');
const noSongsEl = document.getElementById('no-songs');
const songViewEl = document.getElementById('song-view');
const viewTitle = document.getElementById('view-title');
const viewAuthor = document.getElementById('view-author');
const viewContent = document.getElementById('view-content');
const btnBack = document.getElementById('btn-back');
const btnDelete = document.getElementById('btn-delete');
const btnEdit = document.getElementById('btn-edit');
const editArea = document.getElementById('edit-area');
const editContent = document.getElementById('edit-content');
const saveEdit = document.getElementById('save-edit');
const cancelEdit = document.getElementById('cancel-edit');
const diagramArea = document.getElementById('diagram-area');
const diagramBox = document.getElementById('diagram-box');

const inputTitle = document.getElementById('input-title');
const inputAuthor = document.getElementById('input-author');
const inputContent = document.getElementById('input-content');
const saveBtn = document.getElementById('save-btn');
const clearFormBtn = document.getElementById('clear-form');
const fileInput = document.getElementById('file-input');
const importInfo = document.getElementById('import-info');
const exportBtn = document.getElementById('export-json');
const clearAllBtn = document.getElementById('clear-all');
const detectInfo = document.getElementById('detect-info');

const pianoBtn = document.getElementById('pianoBtn');
const guitarBtn = document.getElementById('guitarBtn');

/* ======================
   Helpers: storage & escape
   ====================== */
function saveToStorage(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(songs)); }
function loadSongs(){
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    songs = raw ? JSON.parse(raw) : [
      { title: "Someone You Loved", author: "Lewis Capaldi", content: `[Intro]
C#   G#   A#m  F#

[Verse 1]
C#                          G#                              A#m     F#
I'm going under and this time I fear there's no one to save me` }
    ];
    saveToStorage();
  } catch(e){ console.error('loadSongs error', e); songs = []; }
  renderList();
}
function escapeHtml(str){ if(str === undefined || str === null) return ''; return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }

/* ======================
   Render list
   ====================== */
function renderList(){
  songListEl.innerHTML = '';
  if(!songs || songs.length === 0){ noSongsEl.classList.remove('hidden'); return; } else noSongsEl.classList.add('hidden');
  songs.forEach((s,idx) => {
    const li = document.createElement('li');
    li.className = "flex items-center justify-between bg-gray-50 p-2 rounded";
    const left = document.createElement('div');
    left.innerHTML = `<button class="text-left font-medium" onclick="openSong(${idx})">${escapeHtml(s.title)} <span class="text-sm text-gray-500">â€“ ${escapeHtml(s.author || 'Auteur inconnu')}</span></button>`;
    const right = document.createElement('div');
    right.innerHTML = `<button onclick="openSong(${idx})" class="text-xs border p-1 rounded mr-2">Ouvrir</button>
                       <button onclick="deleteSong(${idx})" class="text-xs border p-1 rounded text-red-600">Supprimer</button>`;
    li.appendChild(left); li.appendChild(right); songListEl.appendChild(li);
  });
}

/* ======================
   Title/Author detection
   ====================== */
function isChordToken(token){ return /^[A-G](?:#|b)?(?:m(?!aj)|maj|min|dim|aug|sus|add)?[0-9\/\(\)\-A-Za-z\+]*$/.test(token); }
function isChordLine(line){
  if(!line) return false;
  if(/x-?\d|[0-9]-[0-9]/.test(line)) return true;
  const tokens = line.split(/\s+/).filter(Boolean);
  if(tokens.length === 0) return false;
  let chordCount = 0;
  tokens.forEach(t => { if(isChordToken(t)) chordCount++; });
  if(tokens.length > 0 && (chordCount / tokens.length) >= 0.6) return true;
  if(/^[A-G#b\sm0-9\/\(\)\-]+$/.test(line) && /[A-G]/.test(line)) return true;
  return false;
}
function detectTitleAuthor(text, filename=''){
  if(!text || !text.trim()) return {title: filename || '', author: ''};
  const rawLines = text.split(/\r?\n/);
  const lines = rawLines.map(l => l.trim()).filter(l => l.length > 0);
  if(lines.length === 0) return {title: filename || '', author: ''};
  const keywordRE = /^(CAPO|KEY|PLAY|CHORDS?|TAB|INTRO|VERSE|CHORUS|OUTRO|BRIDGE|REPEAT|PRE-CHORUS)$/i;
  let candidateIndex = -1;
  for(let i=0;i<lines.length;i++){
    const ln = lines[i];
    if(/^\[.*\]$/.test(ln)) continue;
    if(keywordRE.test(ln)) continue;
    if(isChordLine(ln)) continue;
    candidateIndex = i; break;
  }
  if(candidateIndex === -1) candidateIndex = 0;
  const first = lines[candidateIndex];
  let m = first.match(/^(.+?)\s*\(([^)]+)\)\s*$/);
  if(m) return {title: m[1].trim(), author: m[2].trim()};
  m = first.match(/^(.+?)\s*[-â€“â€”]\s*(.+)$/);
  if(m && !keywordRE.test(m[2].trim())) return {title: m[1].trim(), author: m[2].trim()};
  if(!keywordRE.test(first) && !isChordLine(first)){
    if(lines.length > candidateIndex + 1){
      const next = lines[candidateIndex + 1];
      const m2 = next.match(/^\(?([^)\n]{1,80})\)?$/);
      if(m2 && !keywordRE.test(next) && !isChordLine(next)){
        if(/[&\/,]| and |Band|The |featuring|Feat\.|feat\./i.test(next) || /^[A-Z0-9][a-z]/.test(next)){
          return {title: first, author: next.trim()};
        }
      }
    }
    return {title: first, author: ''};
  }
  return {title: filename || lines[0], author: ''};
}
function showDetectInfo(text){ if(!text){ detectInfo.classList.add('hidden'); return; } detectInfo.textContent = text; detectInfo.classList.remove('hidden'); setTimeout(()=> detectInfo.classList.add('hidden'),4000); }

/* ======================
   Open / view / edit / delete
   ====================== */
window.openSong = function(index){
  currentIndex = index;
  const s = songs[index];
  viewTitle.textContent = s.title;
  viewAuthor.textContent = s.author ? `Par ${s.author}` : '';
  viewContent.innerHTML = contentToHTML(s.content || '');
  songViewEl.classList.remove('hidden');
  editArea.classList.add('hidden');
  editContent.value = '';
  diagramArea.classList.add('hidden'); diagramBox.innerHTML = '';
  attachChordClickHandlers();
  songViewEl.scrollTop = 0;
};

btnBack.addEventListener('click', ()=> { songViewEl.classList.add('hidden'); currentIndex = null; });

window.deleteSong = function(index){
  if(!confirm(`Supprimer "${songs[index].title}" ?`)) return;
  songs.splice(index,1); saveToStorage(); renderList(); songViewEl.classList.add('hidden');
};
btnDelete.addEventListener('click', ()=> { if(currentIndex !== null) deleteSong(currentIndex); });

btnEdit.addEventListener('click', ()=> {
  if(currentIndex === null) return;
  editArea.classList.remove('hidden');
  editContent.value = songs[currentIndex].content || '';
  editContent.focus();
});
saveEdit.addEventListener('click', ()=> {
  if(currentIndex === null) return;
  songs[currentIndex].content = editContent.value;
  saveToStorage(); renderList(); openSong(currentIndex); editArea.classList.add('hidden');
});
cancelEdit.addEventListener('click', ()=> editArea.classList.add('hidden'));

/* ======================
   Save new song (works & detection)
   ====================== */
saveBtn.addEventListener('click', ()=> {
  const rawTitle = inputTitle.value.trim();
  const rawAuthor = inputAuthor.value.trim();
  const rawContent = inputContent.value.trim();
  if(!rawContent){ alert("Colle le texte de la chanson (accords + paroles)."); inputContent.focus(); return; }
  let titleToUse = rawTitle;
  let authorToUse = rawAuthor;
  if(!titleToUse){
    const det = detectTitleAuthor(rawContent);
    if(det.title) { titleToUse = det.title; if(!authorToUse) authorToUse = det.author || ''; }
  }
  if(!titleToUse){
    alert("Donne un titre Ã  la chanson ou assure-toi que le texte contient une ligne titre.");
    inputTitle.focus(); return;
  }
  songs.push({ title: titleToUse, author: authorToUse, content: rawContent });
  saveToStorage(); renderList();
  inputTitle.value=''; inputAuthor.value=''; inputContent.value='';
  showDetectInfo("Chanson sauvegardÃ©e âœ”");
});

/* clear form */
clearFormBtn.addEventListener('click', ()=> { inputTitle.value=''; inputAuthor.value=''; inputContent.value=''; });

/* import .txt */
fileInput.addEventListener('change', (ev)=> {
  const files = Array.from(ev.target.files || []);
  if(files.length === 0) return;
  let imported = 0;
  const readers = files.map(file => new Promise(resolve => {
    const reader = new FileReader();
    reader.onload = e => {
      const text = e.target.result;
      const fname = file.name.replace(/\.[^/.]+$/,'');
      const det = detectTitleAuthor(text, fname);
      const useTitle = det.title || fname;
      songs.push({ title: useTitle, author: det.author || '', content: text });
      imported++; resolve();
    };
    reader.readAsText(file,'utf-8');
  }));
  Promise.all(readers).then(()=> {
    saveToStorage(); renderList();
    importInfo.textContent = `${imported} fichier(s) importÃ©(s) avec dÃ©tection automatique.`;
    setTimeout(()=> importInfo.textContent = '', 3000);
    fileInput.value='';
  });
});

/* export / clear all */
exportBtn.addEventListener('click', ()=> {
  const data = JSON.stringify(songs, null, 2);
  const blob = new Blob([data], { type:'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'songs-library.json'; a.click();
  setTimeout(()=> URL.revokeObjectURL(url), 1000);
});
clearAllBtn.addEventListener('click', ()=> {
  if(!confirm("Supprimer TOUTES les chansons ?")) return;
  songs = []; saveToStorage(); renderList(); songViewEl.classList.add('hidden'); alert("Toutes les chansons ont Ã©tÃ© supprimÃ©es.");
});

/* auto-detect while typing into textarea (fills title/author if empty) */
let lastDetection = {title:'', author:''};
inputContent.addEventListener('input', ()=>{
  const txt = inputContent.value.trim();
  if(txt.length < 6) return;
  const det = detectTitleAuthor(txt);
  if((!inputTitle.value || inputTitle.value.trim()==='') && det.title) inputTitle.value = det.title;
  if((!inputAuthor.value || inputAuthor.value.trim()==='') && det.author) inputAuthor.value = det.author;
  if((det.title && det.title !== lastDetection.title) || (det.author && det.author !== lastDetection.author)){
    const msg = `DÃ©tectÃ© : ${det.title || '(titre non dÃ©tectÃ©)'}${det.author ? ' â€” ' + det.author : ''}`;
    showDetectInfo(msg); lastDetection = det;
  }
});

/* Toggle instrument */
pianoBtn.addEventListener('click', ()=> {
  instrument = 'piano'; pianoBtn.classList.add('active'); guitarBtn.classList.remove('active');
  if(diagramArea.classList.contains('hidden') === false && currentChordDisplay) showDiagramForChord(currentChordDisplay);
});
guitarBtn.addEventListener('click', ()=> {
  instrument = 'guitar'; guitarBtn.classList.add('active'); pianoBtn.classList.remove('active');
  if(diagramArea.classList.contains('hidden') === false && currentChordDisplay) showDiagramForChord(currentChordDisplay);
});

/* ======================
   Chord tokenization -> safe clickable spans (non-destructive)
   ====================== */

/*
  We'll find chord tokens on each line with a regex and build HTML:
  - we avoid matching letters inside words (e.g., "And") by checking left neighbor and right neighbor.
*/
const CHORD_RE = /([A-G](?:#|b)?(?:m(?!aj)|maj|min|dim|aug|sus|add)?[0-9]*(?:\/[A-G](?:#|b)?)?)/g;

function contentToHTML(text){
  const lines = (text||'').split(/\r?\n/);
  const htmlLines = lines.map(line => processLineForChords(line));
  return htmlLines.join('<br>');
}
function processLineForChords(line){
  let re = new RegExp(CHORD_RE); // non-global for exec not needed; we'll use global exec
  const globalRe = new RegExp(CHORD_RE.source, 'g');
  let out = '';
  let lastIndex = 0;
  let m;
  while((m = globalRe.exec(line)) !== null){
    const idx = m.index;
    const token = m[1];
    // ensure token is not part of a word: char before should not be a letter, char after should not be a lowercase letter
    const beforeChar = (idx-1 >= 0) ? line[idx-1] : null;
    const afterChar = line[globalRe.lastIndex] || null;
    if(beforeChar && /[A-Za-z]/.test(beforeChar)) {
      // skip this match (part of a word)
      continue;
    }
    if(afterChar && /[a-z]/.test(afterChar)) {
      // skip (e.g., "And")
      continue;
    }
    // append escaped segment before match
    out += escapeHtml(line.slice(lastIndex, idx));
    // append chord span (escaped inside)
    out += `<span class="chord-inline" data-chord="${escapeHtml(token)}">${escapeHtml(token)}</span>`;
    lastIndex = globalRe.lastIndex;
  }
  // append remainder
  out += escapeHtml(line.slice(lastIndex));
  return out;
}

/* attach click handlers to chord spans */
function attachChordClickHandlers(){
  const nodes = viewContent.querySelectorAll('.chord-inline');
  nodes.forEach(n => {
    n.style.cursor = 'pointer';
    n.removeEventListener('click', chordClickHandler);
    n.addEventListener('click', chordClickHandler);
  });
}
function chordClickHandler(e){
  const chordText = e.currentTarget.getAttribute('data-chord');
  showDiagramForChord(chordText);
}

/* ======================
   Music theory & diagrams (guitar shapes + piano voicings)
   ====================== */

/* GUITAR SHAPES (strings 6..1, -1 muted, 0 open, >0 fret) - includes Dm explicitly */
const GUITAR_SHAPES = {
  "C":[-1,3,2,0,1,0],
  "Cm":[-1,3,5,5,4,3],
  "C7":[-1,3,2,3,1,0],
  "Cmaj7":[-1,3,2,0,0,0],
  "D":[-1,-1,0,2,3,2],
  "Dm":[-1,-1,0,2,3,1],
  "D7":[-1,-1,0,2,1,2],
  "E":[0,2,2,1,0,0],
  "Em":[0,2,2,0,0,0],
  "E7":[0,2,0,1,0,0],
  "F":[1,3,3,2,1,1],
  "Fm":[1,3,3,1,1,1],
  "G":[3,2,0,0,0,3],
  "Gm":[3,5,5,3,3,3],
  "G7":[3,2,0,0,0,1],
  "A":[-1,0,2,2,2,0],
  "Am":[-1,0,2,2,1,0],
  "A7":[-1,0,2,0,2,0],
  "B":[-1,2,4,4,4,2],
  "Bm":[-1,2,4,4,3,2],
  "Bm7":[-1,2,0,2,2,2],
  "Bb":[1,1,3,3,3,1],
  "F#":[2,4,4,3,2,2],
  "F#m":[2,4,4,2,2,2],
  "Em7":[0,2,2,0,3,0],
  "Am7":[-1,0,2,0,1,0],
  "Dm7":[-1,-1,0,2,1,1],
  "Cadd9":[-1,3,2,0,3,0],
  "Gsus4":[3,2,0,0,1,3],
  "Asus4":[-1,0,2,2,3,0],
  "Dsus4":[-1,-1,0,2,3,3],
  "Fsus2":[1,3,3,3,1,1],
  "Bm7-5":[-1,2,3,2,3,-1]
};

/* enharmonic map and note semitone table */
const ENHARMONIC = {"Db":"C#","Eb":"D#","Gb":"F#","Ab":"G#","Bb":"A#"};
const NOTE_TO_SEMITONE = {'C':0,'C#':1,'Db':1,'D':2,'D#':3,'Eb':3,'E':4,'F':5,'F#':6,'Gb':6,'G':7,'G#':8,'Ab':8,'A':9,'A#':10,'Bb':10,'B':11};

/* parse chord name */
function parseChordName(chordStr){
  const s = String(chordStr).trim();
  const m = s.match(/^([A-G][#b]?)(.*)$/);
  if(!m) return null;
  const root = m[1];
  const rest = (m[2]||'').toLowerCase();
  let type = 'major';
  if(/^(m(?!aj)|min)/.test(rest)) type = 'minor';
  if(/maj7|M7/.test(rest)) type = 'maj7';
  if(/m7/.test(rest)) type = 'm7';
  if(/7(?!.*maj)/.test(rest) && !/m7/.test(rest)) type = '7';
  if(/sus4/.test(rest)) type = 'sus4';
  if(/sus2/.test(rest)) type = 'sus2';
  if(/dim/.test(rest)) type = 'dim';
  if(/add9/.test(rest)) type = 'add9';
  return { root, type, raw: s };
}

/* piano voicings */
function generatePianoVoicings(chordStr){
  const p = parseChordName(chordStr);
  if(!p) return null;
  const root = p.root.replace('b','b').replace('â™¯','#');
  const sem = NOTE_TO_SEMITONE[root] === undefined ? NOTE_TO_SEMITONE[ENHARMONIC[root]||root] : NOTE_TO_SEMITONE[root];
  if(sem === undefined) return null;
  let intervals = [0,4,7]; if(p.type === 'minor') intervals=[0,3,7];
  if(p.type === '7') intervals=[0,4,7,10]; if(p.type === 'm7') intervals=[0,3,7,10];
  const NOTES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const notes = intervals.map(i => NOTES[(sem + i) % 12]);
  // three voicings (root, 1st inv, 2nd inv)
  const v1 = notes.slice(0,3).join(' ');
  const v2 = notes.slice(1).concat(notes.slice(0,1)).join(' ');
  const v3 = notes.slice(2).concat(notes.slice(0,2)).join(' ');
  return [v1, v2, v3];
}

/* render guitar shape */
function renderGuitarShape(shape, chordLabel=''){
  const container = document.createElement('div');
  container.innerHTML = `<div class="kbd">${escapeHtml(chordLabel)} â€” guitare</div>`;
  const header = document.createElement('div'); header.style.display='flex'; header.style.justifyContent='center'; header.style.gap='0'; header.style.marginBottom='6px';
  for(let s=6;s>=1;s--){
    const h = document.createElement('div'); h.style.width='40px'; h.style.textAlign='center';
    const val = shape[s-1];
    if(val === -1) h.innerHTML = '<span class="muted">x</span>';
    else if(val === 0) h.innerHTML = '<span class="open">o</span>';
    else h.innerHTML = `<span class="small">f${val}</span>`;
    header.appendChild(h);
  }
  const grid = document.createElement('div'); grid.className='guitar-grid';
  for(let fret=1; fret<=5; fret++){
    for(let s=6; s>=1; s--){
      const cell = document.createElement('div'); cell.className='guitar-cell';
      const val = shape[s-1];
      if(val > 0 && val === fret){
        const dot = document.createElement('div'); dot.className='dot'; cell.appendChild(dot);
      }
      grid.appendChild(cell);
    }
  }
  container.appendChild(header); container.appendChild(grid);
  return container;
}

/* heuristic builder for missing shapes */
function buildHeuristicGuitarShape(chordName){
  const p = parseChordName(chordName);
  if(!p) return [-1,-1,-1,-1,-1,-1];
  const root = p.root;
  const rootSemi = NOTE_TO_SEMITONE[root] === undefined ? NOTE_TO_SEMITONE[ENHARMONIC[root]||root] : NOTE_TO_SEMITONE[root];
  if(rootSemi === undefined) return [-1,-1,-1,-1,-1,-1];
  let intervals = [0,4,7]; if(p.type==='minor') intervals=[0,3,7];
  if(p.type==='7') intervals=[0,4,7,10]; if(p.type==='m7') intervals=[0,3,7,10];
  const semSet = new Set(intervals.map(i => (rootSemi + i) % 12));
  const open = [NOTE_TO_SEMITONE['E'], NOTE_TO_SEMITONE['A'], NOTE_TO_SEMITONE['D'], NOTE_TO_SEMITONE['G'], NOTE_TO_SEMITONE['B'], NOTE_TO_SEMITONE['E']];
  const shape = [];
  for(let si=0; si<6; si++){
    if(semSet.has(open[si])) { shape.push(0); continue; }
    let chosen = null;
    for(let f=1; f<=5; f++){
      if(semSet.has((open[si]+f)%12)){ chosen = f; break; }
    }
    if(chosen === null){
      for(let f=6; f<=12; f++){ if(semSet.has((open[si]+f)%12)){ chosen=f; break; } }
    }
    shape.push(chosen === null ? -1 : chosen);
  }
  return shape;
}

/* render piano voicings */
function renderPianoVoicings(voicings, chordLabel=''){
  const container = document.createElement('div');
  container.innerHTML = `<div class="kbd">${escapeHtml(chordLabel)} â€” piano</div>`;
  voicings.forEach(v=>{
    const block = document.createElement('div'); block.style.marginBottom='8px';
    block.innerHTML = `<div class="small" style="text-align:center;margin-bottom:6px">${escapeHtml(v)}</div>`;
    const keysDiv = document.createElement('div'); keysDiv.className='piano-row';
    const keysOrder = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    keysOrder.forEach(note=>{
      const key = document.createElement('div');
      if(note.includes('#')){
        key.className='black-key';
        if(v.split(' ').includes(note)) key.classList.add('black-active');
      } else {
        key.className='white-key';
        if(v.split(' ').includes(note)) key.classList.add('white-active');
      }
      const lab = document.createElement('div'); lab.style.marginBottom='6px'; lab.style.fontSize='10px'; lab.style.color='#444';
      lab.textContent = note.replace('#','â™¯');
      key.appendChild(lab);
      keysDiv.appendChild(key);
    });
    block.appendChild(keysDiv);
    container.appendChild(block);
  });
  return container;
}

/* central function: show/hide diagram when chord clicked */
function showDiagramForChord(rawChord){
  // toggle: if same chord already shown -> hide
  if(currentChordDisplay === rawChord && diagramArea.classList.contains('hidden') === false){
    diagramArea.classList.add('hidden'); diagramBox.innerHTML = ''; currentChordDisplay = null; return;
  }
  diagramArea.classList.remove('hidden'); diagramBox.innerHTML = ''; currentChordDisplay = rawChord;
  const norm = String(rawChord).replace('â™¯','#').replace('â™­','b').replace(/[.,;]$/,'');
  if(instrument === 'guitar'){
    // try direct lookup
    let shape = GUITAR_SHAPES[norm] || GUITAR_SHAPES[ENHARMONIC[norm]];
    if(!shape){
      const p = parseChordName(norm);
      if(p){
        let cand = p.root;
        if(p.type === 'minor') cand = p.root + 'm';
        else if(p.type === '7') cand = p.root + '7';
        else if(p.type === 'm7') cand = p.root + 'm7';
        else cand = p.root;
        shape = GUITAR_SHAPES[cand] || GUITAR_SHAPES[ENHARMONIC[cand]];
      }
    }
    if(!shape) shape = buildHeuristicGuitarShape(norm);
    diagramBox.appendChild(renderGuitarShape(shape, norm));
  } else {
    const voicings = generatePianoVoicings(norm);
    if(!voicings) diagramBox.innerHTML = `<div class="kbd">Accord non reconnu: ${escapeHtml(norm)}</div>`;
    else diagramBox.appendChild(renderPianoVoicings(voicings, norm));
  }
  diagramBox.scrollIntoView({behavior:'smooth', block:'center'});
}

/* attach chord listeners after rendering view */
function attachChordClickHandlers(){
  const nodes = viewContent.querySelectorAll('.chord-inline');
  nodes.forEach(n => {
    n.style.cursor = 'pointer';
    n.removeEventListener('click', chordClickHandler);
    n.addEventListener('click', chordClickHandler);
  });
}
function chordClickHandler(e){ const chordText = e.currentTarget.getAttribute('data-chord'); showDiagramForChord(chordText); }

/* ======================
   Init
   ====================== */
loadSongs();

/* expose */
window.openSong = window.openSong;
window.deleteSong = window.deleteSong;
</script>
</body>
</html>
